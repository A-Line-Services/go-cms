package cms

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// GenerateConfig holds settings for route code generation.
type GenerateConfig struct {
	// PagesDir is the path to the pages directory to scan.
	PagesDir string

	// ModulePath is the Go module path (e.g. "myapp" or "github.com/user/myapp").
	ModulePath string

	// Package is the Go package name for the generated file (default: "main").
	Package string

	// PagesPackage is the import name for the root pages directory
	// relative to ModulePath (default: "pages").
	PagesPackage string
}

// collectionInfo groups a listing + entry route for a collection directory.
type collectionInfo struct {
	basePath string // URL path, e.g. "/blog"
	label    string // human-readable, e.g. "Blog"
	pkg      string // Go package name, e.g. "blog"
}

// layoutInfo describes a layout.templ file discovered during scanning.
type layoutInfo struct {
	pathPrefix string // URL path prefix, e.g. "/", "/blog"
	id         string // layout id, e.g. "root", "blog"
	pkg        string // Go package name, e.g. "pages", "blog"
}

// GenerateRoutes produces Go source code that registers all routes
// discovered in the pages directory. The generated code exports a
// RegisterRoutes(app *cms.App) function.
func GenerateRoutes(cfg GenerateConfig) (string, error) {
	if cfg.Package == "" {
		cfg.Package = "main"
	}
	if cfg.PagesPackage == "" {
		cfg.PagesPackage = "pages"
	}

	routes, err := ScanRoutes(cfg.PagesDir)
	if err != nil {
		return "", fmt.Errorf("scanning pages: %w", err)
	}

	// Sort routes for deterministic output.
	sort.Slice(routes, func(i, j int) bool {
		return routes[i].URLPattern < routes[j].URLPattern
	})

	// Separate pages from collections. Group collections by directory.
	var pages []ScannedRoute
	collections := make(map[string]*collectionInfo) // basePath → info
	entryDirs := make(map[string]bool)              // directory has entry.templ

	for _, r := range routes {
		dir := filepath.Dir(r.FilePath)
		if dir == "." {
			dir = ""
		}

		switch r.Type {
		case TypePage:
			pages = append(pages, r)

		case TypeListing:
			if _, ok := collections[r.URLPattern]; !ok {
				pkg := filepath.Base(dir)
				collections[r.URLPattern] = &collectionInfo{
					basePath: r.URLPattern,
					label:    titleFromPath(r.URLPattern),
					pkg:      pkg,
				}
			}

		case TypeEntry:
			// Entry belongs to its parent directory's collection.
			basePath := filepath.Dir(r.URLPattern)
			if basePath == "." {
				basePath = "/"
			}
			entryDirs[dir] = true
			if _, ok := collections[basePath]; !ok {
				pkg := filepath.Base(dir)
				collections[basePath] = &collectionInfo{
					basePath: basePath,
					label:    titleFromPath(basePath),
					pkg:      pkg,
				}
			}
		}
	}

	// Scan for layout.templ files.
	var layouts []layoutInfo
	err = filepath.WalkDir(cfg.PagesDir, func(path string, d os.DirEntry, walkErr error) error {
		if walkErr != nil {
			return walkErr
		}
		if d.IsDir() || d.Name() != "layout.templ" {
			return nil
		}
		relDir, _ := filepath.Rel(cfg.PagesDir, filepath.Dir(path))
		relDir = filepath.ToSlash(relDir)

		pathPrefix := "/"
		id := "root"
		pkg := cfg.PagesPackage
		if relDir != "" && relDir != "." {
			pathPrefix = "/" + relDir
			id = filepath.Base(relDir)
			pkg = filepath.Base(relDir)
		}
		layouts = append(layouts, layoutInfo{pathPrefix: pathPrefix, id: id, pkg: pkg})
		return nil
	})
	if err != nil {
		return "", fmt.Errorf("scanning layouts: %w", err)
	}
	sort.Slice(layouts, func(i, j int) bool {
		return layouts[i].pathPrefix < layouts[j].pathPrefix
	})

	// Build imports. Root pages package is always imported.
	// Sub-packages (collections and layouts) are imported with their directory name.
	imports := map[string]string{} // import path → alias (empty = no alias)
	rootPagesImport := cfg.ModulePath + "/" + cfg.PagesPackage
	imports[rootPagesImport] = ""

	// Sort collection keys for deterministic output.
	var collKeys []string
	for k := range collections {
		collKeys = append(collKeys, k)
	}
	sort.Strings(collKeys)

	for _, k := range collKeys {
		c := collections[k]
		importPath := rootPagesImport + "/" + c.pkg
		imports[importPath] = ""
	}

	for _, l := range layouts {
		if l.pkg != cfg.PagesPackage {
			importPath := rootPagesImport + "/" + l.pkg
			imports[importPath] = ""
		}
	}

	// Build the generated source.
	var b strings.Builder

	b.WriteString("// Code generated by go-cms generate — DO NOT EDIT.\n\n")
	fmt.Fprintf(&b, "package %s\n\n", cfg.Package)

	// Imports.
	b.WriteString("import (\n")
	b.WriteString("\tcms \"go.a-line.be/cms\"\n")

	// Sort import paths for deterministic output.
	var importPaths []string
	for p := range imports {
		importPaths = append(importPaths, p)
	}
	sort.Strings(importPaths)

	for _, p := range importPaths {
		fmt.Fprintf(&b, "\t%q\n", p)
	}
	b.WriteString(")\n\n")

	// RegisterRoutes function.
	b.WriteString("// RegisterRoutes registers all pages, layouts, and collections discovered\n")
	b.WriteString("// in the pages directory. Generated from the file structure.\n")
	b.WriteString("func RegisterRoutes(app *cms.App) {\n")

	// Layouts first (outermost → innermost by path prefix sort order).
	for _, l := range layouts {
		fmt.Fprintf(&b, "\tapp.Layout(%q, %q, %s.RootLayout)\n", l.pathPrefix, l.id, l.pkg)
	}
	if len(layouts) > 0 && (len(pages) > 0 || len(collKeys) > 0) {
		b.WriteString("\n")
	}

	// Then pages.
	for _, p := range pages {
		dir := filepath.Dir(p.FilePath)
		fn := funcName(filepath.Base(p.FilePath))
		pkg := cfg.PagesPackage
		if dir != "" && dir != "." {
			pkg = filepath.Base(dir)
		}
		fmt.Fprintf(&b, "\tapp.Page(%q, %s.%s)\n", p.URLPattern, pkg, fn)
	}

	// Then collections.
	if len(collKeys) > 0 && len(pages) > 0 {
		b.WriteString("\n")
	}
	for _, k := range collKeys {
		c := collections[k]
		fmt.Fprintf(&b, "\tapp.Collection(%q, %q, %s.IndexPage, %s.EntryPage)\n",
			c.basePath, c.label, c.pkg, c.pkg)
	}

	b.WriteString("}\n")

	return b.String(), nil
}

// WriteGeneratedRoutes generates route registration code and writes
// it to the specified file.
func WriteGeneratedRoutes(cfg GenerateConfig, outFile string) error {
	code, err := GenerateRoutes(cfg)
	if err != nil {
		return err
	}
	return os.WriteFile(outFile, []byte(code), 0o644)
}

// funcName derives a Go exported function name from a templ filename.
// "index.templ" → "IndexPage", "about.templ" → "AboutPage",
// "contact-us.templ" → "ContactUsPage".
func funcName(filename string) string {
	base := strings.TrimSuffix(filename, ".templ")
	parts := strings.Split(base, "-")
	var result string
	for _, p := range parts {
		if len(p) > 0 {
			result += strings.ToUpper(p[:1]) + p[1:]
		}
	}
	return result + "Page"
}
